---
apiVersion: helm.fluxcd.io/v1
kind: HelmRelease
metadata:
  name: hub
  namespace: sandbox
  annotations:
    fluxcd.io/ignore: true   # temporarily make Flux ignore a manifest if set to true
    fluxcd.io/automated: true  # automated deployment of new container images
    fluxcd.io/tag.scheduler: semver:*
    fluxcd.io/tag.worker: semver:*
spec:
  releaseName: hub
  chart:
    # Helm Charts: https://github.com/jupyterhub/helm-chart
    # Source Repository: https://github.com/jupyterhub/jupyterhub
    repository: https://jupyterhub.github.io/helm-chart/
    name: jupyterhub
    version: 0.8.2
  valueFileSecrets:
  - name: jhub
  values:
    hub:
      #cookieSecret - Injected by Flux
      imagePullPolicy: Always
      pdb:
        enabled: false
        minAvailable: 0
      annotations:
        iam.amazonaws.com/role: dev-eks-datacube-wms
      extraConfig:
        spawner: |
          #!/usr/bin/env python3

          import json
          import os
          import sys
          import base64
          from kubernetes import client, config
          # install 'cognitojwt' packages to hub container - require to validate user claim.
          try:
            import cognitojwt
          except ImportError:
            import subprocess
            subprocess.call([sys.executable, "-m", "pip", "install", "wheel"])
            subprocess.call([sys.executable, "-m", "pip", "install", "--user", "cognitojwt[sync]"])
          finally:
            sys.path.append(os.path.expanduser('~') + "/.local/lib/python3.6/site-packages")
            import cognitojwt

          def enum(**enums):
            return type('Enum', (), enums)

          async def custom_options_form(self):
            self.log.info("logged in user: %s", self.user.name)
            os.environ['PROFILE_TYPE'] = 'default-profile'
            # setup default profile_list for all users
            default_profile_list = [
              {
                'default': True,
                'display_name': 'AU: Standard environment',
                'description': 'Limited user, 2 Cores, 16G Memory Read access to database and files',
              },
            ]
            self.profile_list = default_profile_list

            cognito_user_groups = enum(
              DEVELOPMENT='dev-group',
              INTERNAL='internal-group',
              TRUSTED='trusted-group',
              DEFAULT='default-group',
              NONE='None'
            )

            try:
              # setup user_details and user_details
              user_details = ""
              access_token = ""
              auth_state = await self.user.get_auth_state()
              if auth_state and "oauth_user" in auth_state:
                user_details = auth_state["oauth_user"]
              if auth_state and "access_token" in auth_state:
                access_token = auth_state["access_token"]
              # self.log.info("user[acces_token]: {}".format(access_token))

              verified_claims = cognitojwt.decode(
                access_token,
                os.getenv('AWS_DEFAULT_REGION', 'ap-southeast-2'),
                os.getenv('JUPYTERHUB_USERPOOL_ID'),
                testmode=False  # Enable token expiration check
              )
              user_group_info = []
              if verified_claims and "cognito:groups" in verified_claims:
                user_group_info = verified_claims["cognito:groups"]
              self.log.info("%s user group info: %s", self.user.name, (','.join(user_group_info)))

              # Use logic here to decide how to configure user profile_list if belongs to user-group
              if cognito_user_groups.DEVELOPMENT in user_group_info:
                # configure your profile_list for 'dev-group' user
                os.environ['PROFILE_TYPE'] = 'dev-profile'
                self.log.info("user belongs to {} cognito group".format(cognito_user_groups.DEVELOPMENT))
                dev_profile_list = [
                  {
                    'default': False,
                    'display_name': 'AU_DEV_SUDO: Standard environment with root user access',
                    'description': 'Root user, 2 Cores, 16G Memory Read access to database and files',
                    'kubespawner_override': {
                      'image': 'opendatacube/jupyterhub:0.2.11-unstable.8.g6c146b9_sudo'
                    }
                  },
                  {
                    'default': False,
                    'display_name': 'AU_DEV_KKODC: Unstable Development environment',
                    'description': 'Limited user, 2 Cores, 16G Memory Read access to database and files',
                    'kubespawner_override': {
                      'image': 'kkodc/sandbox:latest'
                    }
                  },
                  {
                    'default': False,
                    'display_name': 'AU_DEV: Development environment',
                    'description': 'Jupyterhub environment with 4 Cores, 20G Memory Read access to database and files',
                    'kubespawner_override': {
                      'mem_guarantee': '20G',
                      'mem_limit': '20G',
                      'cpu_guarantee': 4,
                      'cpu_limit': 4,
                    },
                  },
                ]
                self.profile_list.extend(dev_profile_list)
              if cognito_user_groups.INTERNAL in user_group_info:
                # configure your profile_list for 'internal-group' user
                self.log.info("user belongs to {} cognito group".format(cognito_user_groups.INTERNAL))
              if cognito_user_groups.TRUSTED in user_group_info:
                # configure your profile_list for 'trusted-group' user
                self.log.info("user belongs to {} cognito group".format(cognito_user_groups.TRUSTED))
            except TypeError as err:
              self.log.error("Type error: {}".format(err))
            except cognitojwt.CognitoJWTException as err:
              self.log.error("Cliam verification issue: {}".format(err))
            except Exception as err:
              self.log.error("Unexpected error: {}".format(err))
            finally:
              # Let KubeSpawner inspect profile_list and decide what to return
              return self._options_form_default()

          def modify_pod_hook(spawner, pod):
            # load extra env varibles for dev-profile
            if 'PROFILE_TYPE' in os.environ and os.environ['PROFILE_TYPE'] == 'dev-profile':
              pod.spec.containers[0].env.extend([
                client.V1EnvVar(
                  name='AWS_ACCESS_KEY_ID',
                  value_from=client.V1EnvVarSource(secret_key_ref=client.V1SecretKeySelector(
                    name='hub-jhub-accesskey',
                    key='AWS_ACCESS_KEY_ID',
                  ))
                ),
                client.V1EnvVar(
                  name='AWS_SECRET_ACCESS_KEY',
                  value_from=client.V1EnvVarSource(secret_key_ref=client.V1SecretKeySelector(
                    name='hub-jhub-accesskey',
                    key='AWS_SECRET_ACCESS_KEY',
                  ))
                ),
                client.V1EnvVar(
                  name='AWS_DEFAULT_REGION',
                  value_from=client.V1EnvVarSource(secret_key_ref=client.V1SecretKeySelector(
                    name='hub-jhub-accesskey',
                    key='AWS_DEFAULT_REGION',
                  ))
                )
              ])
            return pod

          # Set the log level by value or name.
          c.JupyterHub.log_level = 'DEBUG'

          # Enable debug-logging of the single-user server
          c.Spawner.debug = True

          # Enable debug-logging of the single-user server
          c.LocalProcessSpawner.debug = True
          c.Spawner.cmd = ['jupyter-labhub']

          # Override options_form
          c.KubeSpawner.options_form = custom_options_form

          # load extra env variable to pod using secrets
          c.KubeSpawner.modify_pod_hook = modify_pod_hook
#      extraEnv:
#        OAUTH_CALLBACK_URL: ${url}
#        OAUTH2_AUTHORIZE_URL: ${auth_url}
#        OAUTH2_TOKEN_URL: ${token_url}
#        OAUTH2_USERDATA_URL: ${userinfo_url}
    auth:
      type: custom
      custom:
        className: oauthenticator.generic.GenericOAuthenticator
        config:
          login_service: "email"
    proxy:
      #secretToken - Injected by Flux
      nginx:
        image:
          name: quay.io/kubernetes-ingress-controller/nginx-ingress-controller
          tag: 0.21.0
      pdb:
        enabled: false
        minAvailable: 0
    singleuser:
#      extraAnnotations:
#        iam.amazonaws.com/role: ${cluster_name}-wms
      defaultUrl: "/lab"
      memory:
        limit: 16G
      cpu:
        limit: 2
      cloudMetadata:
        enabled: true
      image:
        # Docker Hub: https://hub.docker.com/r/opendatacube/jupyterhub
        # Source Repository: https://github.com/opendatacube/jupyterhub
        name: opendatacube/jupyterhub
        tag: 0.2.13-unstable.1.gac2700f
      extraEnv:
        DB_PORT: "5432"
        #DB_PASSWORD - Injected by Flux
        #DB_USERNAME - Injected by Flux
        #DB_DATABASE - Injected by Flux
        #DB_HOSTNAME - Injected by Flux
        DATACUBE_CONFIG_PATH: "/conf/datacube.conf"
      storage:
        extraVolumes:
        - name: notebooks
          emptyDir: {}
        extraVolumeMounts:
        - name: notebooks
          mountPath: /notebooks
      lifecycleHooks:
        postStart:
          exec:
            command:
            - "bash"
            - "-c"
            - |-
              git clone --depth 1 https://github.com/GeoscienceAustralia/dea-notebooks.git dea-notebooks
              chown 1000:100 dea-notebooks/DEA_sandbox/ -R
              rsync -avu dea-notebooks/DEA_sandbox/ ~/
              rm -rf dea-notebooks
    ingress:
      enabled: true
      annotations:
        kubernetes.io/tls-acme: "true"
        alb.ingress.kubernetes.io/healthcheck-path: /hub/login
        alb.ingress.kubernetes.io/healthcheck-port: traffic-port
        alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
        alb.ingress.kubernetes.io/scheme: internet-facing
        alb.ingress.kubernetes.io/target-type: instance
        kubernetes.io/ingress.class: alb
#        alb.ingress.kubernetes.io/certificate-arn: ${cert_arn}
#      hosts:
#        - app.${domain_name}
      pathSuffix: "*"